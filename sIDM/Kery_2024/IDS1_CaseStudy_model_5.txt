
    model{
      
      # Priors for all parameters in IDS model
      # -------------------------------------------------------------------
      # Partly different parameters in the detectability-perceptibility component 
	    # of the detection model for the DS and the PC portions of the data
      for(d in 1:2){           # d indexes the two data types: DS vs. PC
        alpha0[d] <- log(mean.sigma[d])  # sigma intercept on log scale and ...
        mean.sigma[d] ~ dunif(0, 1)    # ... on the natural scale (0 - 1 km)
        tau.eps[d] <- pow(sd.eps[d], -2)
		    sd.eps[d] ~ dt(0, 1, 1)I(0,)     # Magnitude of that noise
      }
      # Covariates:
      alpha1 ~ dnorm(0, 1)     # Canopy cover
      alpha2 ~ dnorm(0, 1)     # Urban area

      # Shared parameters in the availability component of the detection model
      gamma0 <- log(mean.phi)  # phi intercept on log scale and ...
      mean.phi ~ dunif(0, 1)   # ... on natural scale
	    # mean.phi ~ dbeta(2, 2)   # ... on natural scale
      gamma1 ~ dnorm(0, 1)     # Effect of day of year on singing rate
      gamma2 ~ dnorm(0, 1)     # Effect of day of year on singing rate (quadratic)
      gamma3 ~ dnorm(0, 1)     # Effect of time of day on singing rate
      gamma4 ~ dnorm(0, 1)     # Effect of time of day on singing rate (quadratic)

      # Shared parameters in the abundance model
      # Random intercept for each year
      for (i in 1:nyear) {     # Loop over 7 years
        ann.beta0[i] ~ dnorm(beta0, tau.beta0)
      }
      beta0 <- log(mean.lambda)  # lambda intercept on log scale and ...
      mean.lambda ~ dnorm(0, 0.001)I(0,) # ... on natural scale
      tau.beta0 <- pow(sd.beta0,-2) 
      sd.beta0 ~ dt(0, 1, 2)I(0,) # Magnitude of noise in lambda intercept
      # Covariates:
      beta1 ~ dnorm(0, 1)      # Effect of habitat (canopy cover) on abundance
      beta2 ~ dnorm(0, 0.1)    # Effect of habitat (canopy cover) on abundance (quadratic)
      beta3 ~ dnorm(0, 1)      # Effect of elevation on abundance
      beta4 ~ dnorm(0, 1)      # Effect of elevation on abundance (quadratic)
      
      # Submodel for the DS data
      # -------------------------------------------------------------------
      # Hierarchical construction of the likelihood
      # Model for binned distance observations of every detected individual
      for(i in 1:nind){       # Loop over all detected individuals
        dclass[i] ~ dcat(fc[siteDS[i],])               # Part 1 of HM
      }
      
      # Construction of the cell probabilities for the nD distance bands
      # This is for the truncation distance for the DS data (here, newB = 0.3 km)

      for(s in 1:nsites_DS){  # Loop over all sites in data set 1
        for(g in 1:nD){       # midpt = mid-point of each distance band
          log(p[s,g]) <- -midpt[g] * midpt[g] / (2 * sigma[s]^2)
          pi[s,g] <- ((2 * midpt[g] ) / newB^2) * delta # prob. per interval
          f[s,g] <- p[s,g] * pi[s,g]
          fc[s,g] <- f[s,g] / pcap[s]
        }
        # Rectangular approx. of integral that yields the Pr(capture)
        pcap[s] <- sum(f[s,])
        
        ### Log-linear models on abundance, detectability, and availability
        # Abundance (lambda)
        log(lambda1[s]) <- ann.beta0[year_DS[s]] + beta1 * habitat_DS[s] + beta2 * pow(habitat_DS[s],2) + beta3 * elev_DS[s] + beta4 * pow(elev_DS[s],2) # Log-linear model for abundance 
        
        # Detectability/perceptability (sigma)
        log(sigma[s]) <- alpha0[1] + alpha1 * cancovdetect_DS[s] + alpha2 * urbandetect_DS[s] + eps1[s]  # Log-Linear model for detection probability
		      eps1[s] ~ dnorm(0, tau.eps[1])        # Note here eps1 has one precision and below another

        # Availability (phi)
        log(phi[s]) <- gamma0 + gamma1 * day_DS[s] + gamma2 * pow(day_DS[s],2) + gamma3 * time_DS[s] + gamma4 * pow(time_DS[s],2)  # Log-linear model for availability
        theta[s] <- 1-exp(-DSduration[s]*phi[s])  # Effect of duration on availability

        # Multiply availability with detection probability
        pDS[s] <- pcap[s] * theta[s]

        ### Binomial mixture part (in conditional multinomial specification)
        ncap[s] ~ dbin(pDS[s], N1[s])  # Part 2 of HM: number captured
        N1[s] ~ dpois(A_DS * lambda1[s])  # Note use of A_DS as an offset

		  # Assess model fit: compute Bayesian p-value for Freeman-Tukey discrepancy
        # Compute fit statistic for observed data (DS data portion)
        evalDS[s] <- pDS[s] * N1[s]
        EDS[s] <- pow((sqrt(ncap[s]) - sqrt(evalDS[s])), 2)

        # Generate replicate DS count data and compute same fit stats for them
        ncap.new[s] ~ dbin(pDS[s], N1[s])
        EDS.new[s] <- pow((sqrt(ncap.new[s]) - sqrt(evalDS[s])), 2)
	   }
      # Add up fit stats across sites for DS data
      fitDS <- sum(EDS[])
      fitDS.new <- sum(EDS.new[])
      
      # Submodel for the PC data
      # ------------------------
      # Parameters on abundance shared among both submodels (DS, PC),
	    # parameters on availability are mostly shared (same coefficients, different ran-ef variance),
      #	parameters on sigma are different among DS and PC
      # For spatial reconciliation of the data, we use A as an offset
      
      # Likelihood for the PC data
      for(s in 1:nsites_PC){
        
        # Now we compute the average p over all distance bands for the unlimited-distance surveys
        for(g in 1:nDfull){       # midpt = mid-point of each distance band
          log(p2[s,g]) <- -midptFull[g] * midptFull[g] / (2 * sigmaPC[s]^2)
          pi2[s,g] <- ((2 * midptFull[g] ) / fullDistance^2) * delta # prob. per interval
          f2[s,g] <- p2[s,g] * pi2[s,g]
        }
        # Rectangular approx. of integral that yields the Pr(capture)
        pcap2[s] <- sum(f2[s,])
        
        ### Log-linear models on abundance, detectability and availability
        # Abundance
        log(lambda2[s]) <- ann.beta0[year_PC[s]] + beta1 * habitat_PC[s] + beta2 * pow(habitat_PC[s],2) + beta3 * elev_PC[s] + beta4 * pow(elev_PC[s],2) # Log-linear model on abundance 
    
        # Detectability
        log(sigmaPC[s]) <- alpha0[2] + alpha1 * cancovdetect_PC[s] + alpha2 * urbandetect_PC[s] + eps2[s] # Log-Linear model for detection probability
        eps2[s] ~ dnorm(0, tau.eps[2])

        # Availability
        log(phi2[s]) <- gamma0 + gamma1 * day_PC[s] + gamma2 * pow(day_PC[s],2) + gamma3 * time_PC[s] + gamma4 * pow(time_PC[s],2) 
        theta2[s] <- 1-exp(-ebirdDuration[s]*phi2[s]) # Effect of duration on availability

        # Multiply availability with detection probability
        pPC[s] <- pcap2[s] * theta2[s] 

        ### Binomial mixture part 
        N2[s] ~ dpois(A_PC * lambda2[s])
        counts[s] ~ dbinom(pPC[s], N2[s]) 
		
		# Assess model fit: compute Bayesian p-value for Freeman-Tukey discrepancy
        # Compute fit statistic for observed data (PC portion)
        evalPC[s] <- pPC[s] * N2[s]
        EPC[s] <- pow((sqrt(counts[s]) - sqrt(evalPC[s])), 2)

        # Generate replicate point count data and compute same fit stats for them
        counts.new[s] ~ dbin(pPC[s], N2[s])
        EPC.new[s] <- pow((sqrt(counts.new[s]) - sqrt(evalPC[s])), 2)
	   }
      # Add up fit stats across sites for PC data
      fitPC <- sum(EPC[])
      fitPC.new <- sum(EPC.new[])

      # Compute Bayesian p-value for both portions of the data
      bpvDS <- step(fitDS.new - fitDS)
      bpvPC <- step(fitPC.new - fitPC)
    }
    